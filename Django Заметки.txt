C:\src\YuliaProject\yulia


----------------------------------------------------------------------------------------
Создание приложений
1. Идем в директорию с manage.py: cmd -> cd directory

2. Создать новое приложение: python manage.py startapp [название нового приложения]

3. Зарегестрировать новое приложение в настройках фреймворка: в папке конфигурации (основная папка проекта) 
-> settings.py -> Раздел INSTALLED_APPS -> Добавляем добавленное приложение. Для этого в этот раздел добавляем 
'[название нового приложения].apps.[название нового приложения]Config' (поскольку Django фактически ссылается на 
файл apps.py в новом созданном приложении, а в этом файле на автоматически созданный класс
[название нового приложения]Config, прописываем ссылку сразу на него).

4. Создаем url и вид нового приложения. Для этого:
4.1 Идем в views.py в новом созданном приложении. В него копируем: 

from django.shortcuts import render
from django.http import HttpResponse

def [название функции](request):
    return render(request, '[название функции].html')

4.2 Идем в url.py в папке основной конфигурации. В него добавляем путь на новое приложение в раздел urlpatterns
под функцией path:

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    ...
    path('[ссылка]/', include('[название нового приложения].urls')), # Добавляет путь по умолчанию http://127.0.0.1:8000/[ссылка]/
] 

4.3 Идем в urls.py в новом созданном приложении. В него копируем: 

from django.urls import path
from . import views

urlpatterns = [
    path('', views.[название функции в views.py нового созданного приложения, см. п.4.1], name = '[название функции]'),
]

4.4 Создаем html для отображения страницы. Для этого в templates создаем файл [название функции].html (см.п.4.1), 
в нем указываем вид страницы.

ПОСЛЕ КАЖДОГО ЭТАПА СОХРАНЯЕМ, ИНАЧЕ НЕ ВИДИТ ИЗМЕНЕНИЯ.

----------------------------------------------------------------------------------------
Базовые команды для базы даннных

python manage.py shell - Базовая командная строка
python manage.py shell_plus -  Расширенная командная строка через Django-extentions https://github.com/django-extensions/django-extensions 
python manage.py shell_plus --print-sql - Расширенная командная строка через Django-extentions с выводом команд на SQL

Самое простое добавление записи в БД
[переменная]=[Класс в models.py]()
[переменная].[Название колонки]='[Значение]'
[переменная].save()
SQL: INSERT INTO DATA_BASE() VALUES()

Методы объектов через Manager
1. Добавление записи в БД
[Класс в models.py].objects.create([Название колонки1]='[Значение]',[Название колонки2]='[Значение]',...)  
SQL: INSERT INTO DATA_BASE() VALUES()

2.1 Просмотр списка всех записей в БД
[Класс в models.py].objects.all()  
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE()

2.2 Просмотр списка первых n записей в БД
[Класс в models.py].objects.all()[:n]  
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() LIMIT [n]

3 Просмотр списка всех записей в БД по критерию
[Класс в models.py].objects.filter([Название колонки1]='[Значение]',[Название колонки2]='[Значение]',...)  
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() WHERE [Название колонки1]='[Значение]' AND [Название колонки2]='[Значение]' AND ...

4 Просмотр списка всех записей в БД по lookups https://docs.djangoproject.com/en/5.1/ref/models/querysets/#field-lookups. Например:
4.1 <имя атрибута>__gte - сравнение больше или равно (>=)
[Класс в models.py].objects.filter(pk__gte=2) --> Просмотр списка всех записей с id >= 2  
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() WHERE id>=2

4.2 <имя атрибута>__gt - сравнение больше (>)
[Класс в models.py].objects.filter(pk__gt=2) --> Просмотр списка всех записей с id > 2  
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() WHERE id>2 

4.3 <имя атрибута>__lte - сравнение меньше или равно (<=)
[Класс в models.py].objects.filter(pk__lte=2) --> Просмотр списка всех записей с id <= 2  
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() WHERE id<=2

4.4 <имя атрибута>__lt - сравнение меньше (<)
[Класс в models.py].objects.filter(pk__lt=2) --> Просмотр списка всех записей с id < 2  
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() WHERE id<2

4.5 <имя атрибута>__contains - фильтрация по содержанию части текста
[Класс в models.py].objects.filter(title__contains='ли') --> Просмотр списка всех записей, содержащих в колонке title фрагмент текста 'ли'
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() WHERE title LIKE '%ли%' ESCAPE '\'

4.6 <имя атрибута>__in - отбор по содержанию в назначенном диапазоне
[Класс в models.py].objects.filter(pk__in=[2,5,11,12]) --> Просмотр списка всех записей, id которых 2, 5, 11 или 12. Если id не в данном диапазоне - не отбирается
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() WHERE id IN [2,5,11,12]

5. Просмотр списка всех записей в БД кроме критерия
[Класс в models.py].objects.exclude(pk=2) --> Просмотр списка всех записей, id которых не равен 2
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() WHERE NOT id=2

6. Просмотр одной отобранной записи в БД
[Класс в models.py].objects.get(pk=2) --> Просмотр одной отобранной записи, id которой равен 2
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() WHERE id=2
Разница с objects.filter: filter возвращает список значений [], даже если значение одно. get всегда возвращает одно значение, если значений по отбору больше одного, то возвращает ошибку. 

7.1 Сортировка списка всех записей в БД по критерию по убыванию
[Класс в models.py].objects.all().order_by("title") --> Сортировка списка всех записей по полю title по убыванию
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() ORDER BY "title" ASC

7.2 Сортировка списка всех записей в БД по критерию по возрастанию
[Класс в models.py].objects.all().order_by("-title") --> Сортировка списка всех записей по полю title по возрастанию (добавляется минус перед названием поля)
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() ORDER BY "title" DESC

7.3 Сортировка списка отфильтрованных записей в БД по критерию по убыванию
[Класс в models.py].objects.filter(pk__lte=4).order_by("title") --> Сортировка по полю title по убыванию списка записей с id<=4 
SQL: SELECT [ALL COLUMNS] FROM DATA_BASE() WHERE id <= 4 ORDER BY "title" ASC

8. Можно добавить подкласс Meta в models.py и в нем указать базовые настройки базы данных https://docs.djangoproject.com/en/5.1/ref/models/options/#indexes

Самое простое изменение значения в БД
c=Coffee.objects.get(pk=1)
c.content='Cappuchino, Espresso, Earl gray tea, Mochaccino'
c.save()
SQL: UPDATE DATA_BASE() SET [COLUMNS] WHERE id=1

Методы объектов через Manager
1. Изменение всех записей в БД по определенному полю
[Класс в models.py].objects.update([Название колонки]='[Новое значение]')  
SQL: UPDATE DATA_BASE() SET [Название колонки]='[Новое значение]'

2. Изменение отобранных записей в БД по определенному полю
[Класс в models.py].objects.filter(pk__lte=4).update([Название колонки]='[Новое значение]') --> Изменение значений полей по записям с id<=4  
SQL: UPDATE DATA_BASE() SET [Название колонки]='[Новое значение]' WHERE id <= 4
Objects.update() для метода objects.get() не работает, т.к. работает только для списка записей.

Самое простое удаление записи в БД
c=Coffee.objects.get(pk=1)
c.delete()
SQL: DELETE FROM DATA_BASE() WHERE id=1

Методы объектов через Manager
1. Удаление отобранных записей
[Класс в models.py].objects.filter(pk__lte=4).delete() --> Удаление записей с id<=4  
SQL: DELETE FROM DATA_BASE() WHERE id <= 4

----------------------------------------------------------------------------------------
Базовые команды для базы даннных при связи Many-to-one (ForeignKey)

БД1 - первичная база (Many)
БД2 - вторичная база (One)
foreignkey - название колонки в БД2, связанной с БД1 через ForeignKey

Методы объектов через Manager
1. Обращение к объектам первичной базы через вторичную
[переменная]=БД2.objects.get(pk=1) --> Выбираем объект во вторичной базе с id=1
[переменная].foreignkey --> Вызываем объекты первичной базы, соответствующий выбранному объекту во вторичной базе с id=1
SQL: SELECT [БД1.COLUMNS] FROM [БД1]

2. Обращение к объектам вторичной базы через первичную
[переменная]=БД1.objects.get(pk=1) --> Выбираем объект в первичной базе с id=1
[переменная].[наименование БД2]_set.all() --> Вызываем автоматический атрибут <вторичная модель>_set. Далее выбираем стандартные команды (all(), filter() и т.д.). 
Например в данном случае выбираем все записи из вторичной модели, соответствующие выбранному объекту в первичной базе с id=1
SQL: SELECT [БД2.COLUMNS] FROM [БД2] WHERE [БД2.foreignkey]=1

ВНИМАНИЕ: На уровне модели БД2 в атрибуте ForeignKey может быть указан параметр related_name='[related_name]'. 
Тогда стандартный атрибут <вторичная модель>_set будет заменен на [related_name], например:
[переменная]=БД1.objects.get(pk=1) --> Выбираем объект в первичной базе с id=1
[переменная].[related_name].all() --> Выбираем все за
писи из вторичной модели, соответствующие выбранному объекту в первичной базе с id=1

3. Фильтрация вторичной базы по колонке вторичной базы foreignkey
[БД2].objects.filter(foreignkey_id__in=[2,5,11,12]) --> Просмотр списка всех записей, foreignkey которых 2, 5, 11 или 12. Если id не в данном диапазоне - не отбирается
SQL: SELECT [БД2.COLUMNS] FROM [БД2] WHERE foreignkey_id IN [2,5,11,12]

ВНИМАНИЕ: Django автоматически прибавляет "id" к наименованию колонки foreignkey. 
БД2.objects.foreignkey_id --> Вызывает записи по колонке foreignkey в БД2 (не объекты)
БД2.objects.foreignkey --> Вызывает объекты из БД1, сооответствующие foreignkey в БД2

4.1 Фильтрация вторичной базы по колонке первичной базы
[БД2].objects.filter(foreignkey__[Название колонки из первичной базы]=['Значение']) --> Вызываем все значения вторичной базы, которым соответствует определенное значение по определенному полю из первичной базы
SQL: SELECT [БД2.COLUMNS] FROM [БД2] INNER JOIN [БД1] ON [БД2.foreignkey_id = БД1.id] WHERE [БД1.[Название колонки из первичной базы]=['Значение']]

4.2 Фильтрация вторичной базы по колонке первичной базы с дополнительными условиями (lookup)
[БД2].objects.filter(foreignkey__[Название колонки из первичной базы]__contains=['Значение']) --> Вызываем все значения вторичной базы, которым соответствует определенное значение по определенному полю из первичной базы по содержанию
SQL: SELECT [БД2.COLUMNS] FROM [БД2] INNER JOIN [БД1] ON [БД2.foreignkey_id = БД1.id] WHERE [БД1.[Название колонки из первичной базы] LIKE '%['Значение']%' ESCAPE '\'

5.1 Фильтрация первичной базы по колонке вторичной базы, вывод всех категорий (не уникальные)
[БД1].objects.filter([related_name, см. п.2 выше]__[Название колонки из вторичной базы]__contains=['Значение']) --> Вызываем все значения первичной базы, которым соответствует определенное значение по определенному полю из вторичной базы.
SQL: SELECT [БД1.COLUMNS] FROM [БД1] INNER JOIN [БД2] ON [БД1.id = БД2.foreignkey_id] WHERE [БД2.[Название колонки из вторичной базы] LIKE '%['Значение']%' ESCAPE '\'

5.2 Фильтрация первичной базы по колонке вторичной базы, вывод уникальных категорий
[БД1].objects.filter([related_name, см. п.2 выше]__[Название колонки из вторичной базы]__contains=['Значение']).distinct() --> Вызываем все уникальные значения первичной базы, которым соответствует определенное значение по определенному полю из вторичной базы.
SQL: SELECT [БД1.COLUMNS] FROM [БД1] INNER JOIN [БД2] ON [БД1.id = БД2.foreignkey_id] WHERE [БД2.[Название колонки из вторичной базы] LIKE '%['Значение']%' ESCAPE '\'


----------------------------------------------------------------------------------------
Базовые команды для базы даннных при связи Many-to-many (ManyToManyField)

БД1 - База, в которой настроена колонка ManyToManyField
БД2 - Вторая база
БД_tech - Техническая промежуточная база, которую Django создает при связи Many-to-many
manytomany - название колонки в БД1, связанной с БД2 через ManyToManyField

Методы объектов через Manager
1. Назначение соответствий между БД1 и БД2 (добавление записей в БД_tech)
[переменная1],[переменная2],[переменная3]=[БД1].objects.filter(pk__in=[1,2,3]) --> Назначаем для переменной1,переменной2,переменной3 значение в БД1 с id=1,2 и 3
[переменная4],[переменная5],[переменная6]=[БД2].objects.filter(pk__in=[4,5,6]) --> Назначаем для переменной4,переменной5,переменной6 значение в БД2 с id=4,5 и 6
[переменная1].manytomany.set([[переменная4],[переменная5],[переменная6]]) --> Назначаем для переменной1 (БД1, id=1) соответствие переменной4,переменной5,переменной6 (БД2, id=4,5,6)

2. Удаление соответствий между БД1 и БД2 (удаление записи из БД_tech)
[переменная1],[переменная2],[переменная3]=[БД1].objects.filter(pk__in=[1,2,3]) --> Назначаем для переменной1,переменной2,переменной3 значение в БД1 с id=1,2 и 3
[переменная4],[переменная5],[переменная6]=[БД2].objects.filter(pk__in=[4,5,6]) --> Назначаем для переменной4,переменной5,переменной6 значение в БД2 с id=4,5 и 6
[переменная1].manytomany.remove([[переменная4],[переменная5],[переменная6]]) --> Удаляем для переменной1 (БД1, id=1) соответствие переменной4,переменной5,переменной6 (БД2, id=4,5,6)

3. Вывод значений БД1 по значению БД2
[переменная1],[переменная2],[переменная3]=[БД1].objects.filter(pk__in=[1,2,3]) --> Назначаем для переменной1,переменной2,переменной3 значение в БД1 с id=1,2 и 3
[переменная4],[переменная5],[переменная6]=[БД2].objects.filter(pk__in=[4,5,6]) --> Назначаем для переменной4,переменной5,переменной6 значение в БД2 с id=4,5 и 6
[переменная4].[related_name].all() --> Вывод всех значений из БД1, для которых установлено соответствие переменной4 в БД2
ВНИМАНИЕ: На уровне модели БД1 в атрибуте ManyToManyField должен быть указан параметр related_name='[related_name]'. 

4. Вывод значений БД2 по значению БД1
[переменная1],[переменная2],[переменная3]=[БД1].objects.filter(pk__in=[1,2,3]) --> Назначаем для переменной1,переменной2,переменной3 значение в БД1 с id=1,2 и 3
[переменная4],[переменная5],[переменная6]=[БД2].objects.filter(pk__in=[4,5,6]) --> Назначаем для переменной4,переменной5,переменной6 значение в БД2 с id=4,5 и 6
[переменная1].manytomany.all() --> Вывод всех значений из БД2, для которых установлено соответствие переменной1 в БД1

----------------------------------------------------------------------------------------
Базовые команды для базы даннных при связи One-to-one (OneToOneField)

БД1 - База, в которой настроена колонка OneToOneField
БД2 - Вторая база
onetoone - название колонки в БД1, связанной с БД2 через OneToOneField

Методы объектов через Manager
1. Назначение соответствий между БД1 и БД2 через БД1
[переменная1]=[БД1].objects.filter(pk=1) --> Назначаем для переменной1 значение в БД1 с id=1
[переменная2]=[БД2].objects.filter(pk=2) --> Назначаем для переменной2 значение в БД2 с id=2
[переменная1].onetoone=[переменная2] --> Назначаем для переменной1 (БД1, id=1) соответствие переменной2 (БД2, id=2) 
[переменная1].save() --> Сохраняем изменения
ВНИМАНИЕ: Сохранять нужно изменения в той базе, в которой настроена колонка OneToOneField, в данном случае БД1

2. Назначение соответствий между БД1 и БД2 через БД2
[переменная1]=[БД1].objects.filter(pk=1) --> Назначаем для переменной1 значение в БД1 с id=1
[переменная2]=[БД2].objects.filter(pk=2) --> Назначаем для переменной2 значение в БД2 с id=2
[переменная2].[related_name]=[переменная1] --> Назначаем для переменной2 (БД2, id=2) соответствие переменной1 (БД1, id=1) 
[переменная1].save() --> Сохраняем изменения
ВНИМАНИЕ: Сохранять нужно изменения в той базе, в которой настроена колонка OneToOneField, в данном случае БД1
ВНИМАНИЕ: На уровне модели БД1 в атрибуте OneToOneField должен быть указан параметр related_name='[related_name]'. 

3. Вывод значений БД1 по значению БД2
[переменная1]=[БД1].objects.filter(pk=1) --> Назначаем для переменной1 значение в БД1 с id=1
[переменная2]=[БД2].objects.filter(pk=2) --> Назначаем для переменной2 значение в БД2 с id=2
[переменная2].[related_name] --> Вывод значения из БД1, для которого установлено соответствие переменной2 в БД2
ВНИМАНИЕ: На уровне модели БД1 в атрибуте OneToOneField должен быть указан параметр related_name='[related_name]'. 

4. Вывод значений БД2 по значению БД1
[переменная1]=[БД1].objects.filter(pk=1) --> Назначаем для переменной1 значение в БД1 с id=1
[переменная2]=[БД2].objects.filter(pk=2) --> Назначаем для переменной2 значение в БД2 с id=2
[переменная1].onetoone --> Вывод значения из БД2, для которого установлено соответствие переменной1 в БД1


----------------------------------------------------------------------------------------
Команды для базы даннных для объектов класса Q()

БД - База данных
Для начала работы нужно импортировать класс Q():
from django.db.models import Q

Базовый приоритет выполнения операторов:
~ (NOT) - Самый высокий приоритет
& (AND) - Средний приоритет
| (OR) - Самый низкий приоритет

1. Вывод значений по оператору AND
[БД].objects.filter(Q(pk__lt=5) & Q(cat_id=2)) --> Вывод всех значений, для которых id<5 и cat_id=2
SQL: SELECT [ALL COLUMNS] FROM [БД] WHERE cat_id=2 AND id<5

2. Вывод значений по оператору OR
[БД].objects.filter(Q(pk__lt=5) | Q(cat_id=2)) --> Вывод всех значений, для которых id<5 или cat_id=2
SQL: SELECT [ALL COLUMNS] FROM [БД] WHERE cat_id=2 OR id<5

3. Вывод значений по оператору NOT
[БД].objects.filter(~Q(pk__lt=5) | Q(cat_id=2)) --> Вывод всех значений, для которых id не меньше 5 или cat_id=2
SQL: SELECT [ALL COLUMNS] FROM [БД] WHERE cat_id=2 OR NOT id<5

4. Комбинация отбора по классу Q() и простого запроса
[БД].objects.filter(Q(pk__lt=5) | Q(cat_id=2), title__contains='ли') --> Вывод всех значений, для которых (id<5 или cat_id=2) и title содержит 'ли'
SQL: SELECT [ALL COLUMNS] FROM [БД] WHERE (cat_id=2 OR id<5) AND title LIKE '%ли%' ESCAPE '\'

ВНИМАНИЕ: Простой запрос не может идти перед классом Q(), только после. Следующий запрос вызовет ошибку:
[БД].objects.filter(title__contains='ли', Q(pk__lt=5) | Q(cat_id=2))

Чтобы данный запрос не вызывал ошибку, нужно обернуть первое условие в класс Q():
[БД].objects.filter(Q(title__contains='ли'), Q(pk__lt=5) | Q(cat_id=2))
SQL: SELECT [ALL COLUMNS] FROM [БД] WHERE title LIKE '%ли%' ESCAPE '\' AND (cat_id=2 OR id<5)
ВНИМАНИЕ: Использование ',' понижает приоритет AND. Чтобы AND обрабатывался на одном уровне, нужно использовать &, см. п.5

5. Комбинация операторов AND и OR
[БД].objects.filter(Q(title__contains='ли') & Q(pk__lt=5) | Q(cat_id=2)) --> Вывод всех значений, для которых title содержит 'ли' и id<5 или cat_id=2
SQL: SELECT [ALL COLUMNS] FROM [БД] WHERE title LIKE '%ли%' ESCAPE '\' AND cat_id=2 OR id<5


----------------------------------------------------------------------------------------
Методы выбора записей

1.1 Вывод первого элемента в выборке без указания критерия отбора выборки
[БД].objects.first() --> Вывод первого элемента в выборке QuerySet (не в базе данных). Если не установлен критерий отбора, по какому полю отбирать, по умолчанию отбор по primary key

1.2 Вывод первого элемента в выборке с указанием критерия отбора выборки
[БД].objects.order_by('cat_id').first() --> Вывод первого элемента в выборке QuerySet (не в базе данных) по полю cat_id

1.3 Вывод первого элемента в выборке с указанием критерия отбора выборки
[БД].objects.order_by('-cat_id').first() --> Вывод первого элемента в выборке QuerySet (не в базе данных) по полю cat_id с обратной сортировкой

2.1 Вывод последнего элемента в выборке без указания критерия отбора выборки
[БД].objects.last() --> Вывод последнего элемента в выборке QuerySet (не в базе данных). Если не установлен критерий отбора, по какому полю отбирать, по умолчанию отбор по primary key

2.2 Вывод последнего элемента в выборке с указанием критерия отбора выборки
[БД].objects.order_by('cat_id').last() --> Вывод последнего элемента в выборке QuerySet (не в базе данных) по полю cat_id

2.3 Вывод первого элемента в выборке с указанием критерия отбора выборки
[БД].objects.order_by('-cat_id').last() --> Вывод последнего элемента в выборке QuerySet (не в базе данных) по полю cat_id с обратной сортировкой

3.1 Вывод самого раннего элемента в выборке по дате без указания критерия отбора выборки
[БД].objects.earliest('time_update') --> Вывод самого раннего элемента в выборке QuerySet (не в базе данных) по полю даты time_update

3.2 Вывод самого раннего элемента в выборке по дате с указанием критерия отбора выборки
[БД].objects.filter(cat_id=2).earliest('time_update') --> Вывод самого раннего элемента в выборке QuerySet (не в базе данных) по полю даты time_update, где поле cat_id=2

4.1 Вывод самого позднего элемента в выборке по дате без указания критерия отбора выборки
[БД].objects.latest('time_update') --> Вывод самого позднего элемента в выборке QuerySet (не в базе данных) по полю даты time_update

4.2 Вывод самого позднего элемента в выборке по дате с указанием критерия отбора выборки
[БД].objects.filter(cat_id=2).latest('time_update') --> Вывод самого позднего элемента в выборке QuerySet (не в базе данных) по полю даты time_update, где поле cat_id=2

5.1 Вывод предыдущей записи относительно выбранной записи без указания критерия отбора выборки
[переменная]=[БД].objects.get(pk=2) --> Устанавливаем значение в переменную по id=2
[переменная].get_previous_by_time_update() --> Вывод элемента в выборке, предшествующего элементу с id=2 по полю time_update

5.2 Вывод предыдущей записи относительно выбранной записи с указанием критерия отбора выборки
[переменная]=[БД].objects.get(pk=2) --> Устанавливаем значение в переменную по id=2
[переменная].get_previous_by_time_update(title__contains='ли') --> Вывод элемента в выборке, предшествующего элементу с id=2 по полю time_update, для которого поле title содержит 'ли'

6.1 Вывод следующей записи относительно выбранной записи без указания критерия отбора выборки
[переменная]=[БД].objects.get(pk=2) --> Устанавливаем значение в переменную по id=2
[переменная].get_next_by_time_update() --> Вывод элемента в выборке, следующий за элементом с id=2 по полю time_update

6.2 Вывод следующей записи относительно выбранной записи с указанием критерия отбора выборки
[переменная]=[БД].objects.get(pk=2) --> Устанавливаем значение в переменную по id=2
[переменная].get_next_by_time_update(title__contains='ли') --> Вывод элемента в выборке, следующий за элементом с id=2 по полю time_update, для которого поле title содержит 'ли'

7.1 Проверка существования хотя бы одной записи в выборке 
[переменная]=[БД].objects.get(pk=2) --> Устанавливаем значение в переменную по id=2
[переменная].objects.exists() --> Проверка существования хотя бы одной записи в выборке по id=2. Возвращает True если есть хотя бы одна запись, False если нет записей

7.2 Проверка существования хотя бы одной записи в выборке 
[БД].objects.filter(pk=2).exists() --> Проверка существования хотя бы одной записи в выборке по id=2. Возвращает True если есть хотя бы одна запись, False если нет записей

8.1 Вывод количества записей в выборке
[переменная]=[БД].objects.get(pk=2) --> Устанавливаем значение в переменную по id=2
[переменная].objects.count() --> Вывод количества записей в выборке по id=2. 

8.2 Вывод количества записей в выборке
[БД].objects.filter(pk=2).count() --> Вывод количества записей в выборке по id=2. 


----------------------------------------------------------------------------------------
Команды для базы даннных для объектов класса F()

БД - База данных
Для начала работы нужно импортировать класс F():
from django.db.models import F

1.1 Обращение к полю в базе данных 
[БД].objects.update(column_count=F('column_count')+1) --> Через класс F обращаемся к значению в колонке column_count и увеличиваем его на 1. Поскольку не заданы критерии отбора, увеличиваются все значения по данному полю.
SQL: UPDATE [БД] SET m_count=m_count+1
ВНИМАНИЕ: Рекомендуется делать счетчики через класс F как в примере выше, а не счетчик вида column_count += 1, т.к. в последнем варианте в Django возможны сбои и некорректные расчеты 
при одновременном обращении к значениям несколькими пользователями.

1.2 Обращение к полю в базе данных 
[переменная]=[БД].objects.get(pk=1) --> Устанавливаем значение в переменную по id=1
[переменная].column_count=F('column_count')+1 --> Через класс F обращаемся к значению в колонке column_count и увеличиваем его на 1 для значения с id=1
[переменная].save()
SQL: UPDATE [БД] SET m_count=m_count+1 WHERE id=1


----------------------------------------------------------------------------------------
Команды для базы даннных для метода annotate()

БД - База данных
Для работы используются Aggregation functions https://docs.djangoproject.com/en/4.2/ref/models/querysets/#aggregation-functions
Для начала работы их нужно импортировать, например:
from django.db.models import Value, Count

1.1 Добавление "виртуального" поля, которого нет в базе данных, в выборку
[переменная]=[БД].objects.all().annotate(virtual_column=Value(True)) --> Устанавливаем в переменную список всех значений по созданному "виртуальному" полю virtual_column. В данном примере в поле было установлено значение True.

СПРАВОЧНО: Посмотреть значение данной колонки в командной строке можно введя следующий код:
for i in [переменная]:
	print (list(i.__dict__.values()))

1.2 Добавление "виртуального" поля, которого нет в базе данных, в выборку
[переменная]=[БД].objects.all().annotate(virtual_column=F('cat_id')+20) --> Устанавливаем в переменную список всех значений по созданному "виртуальному" полю virtual_column. В данном примере в поле была установлена сумма
поле cat_id+20 с использованием класса F()

СПРАВОЧНО: Если нет критериев отбора, то all() в примере выше писать не обязательно. 
Однако если есть критерии отбора, то вместо all() можно указать методы filter() и проч.


----------------------------------------------------------------------------------------
Команды для базы даннных для аггрегирующих функций

БД - База данных
Для работы используются Aggregation functions https://docs.djangoproject.com/en/4.2/ref/models/querysets/#aggregation-functions
Для начала работы их нужно импортировать, например:
from django.db.models import Count, Sum, Avg, Max, Min

1. Вывод количества записей в базе данных
[БД].objects.count()
SQL: SELECT COUNT(*) AS '__count' FROM [БД]

2.1 Вывод минимума по полю. Для максимума все аналогично, используется функция Max()
[БД].objects.aggregate(Min('age')) --> Вывод минимума по полю age {'age_min': 25}
SQL: SELECT MIN age AS 'age__min' FROM [БД]

2.2 Вывод минимума по полю с созданием собственного имени для ключа. Для максимума все аналогично, используется функция Max()
[БД].objects.aggregate(young=Min('age')) --> Вывод минимума по полю age {'young': 25}
SQL: SELECT MIN age AS 'young' FROM [БД]

3.1 Вывод расчетного значения
[БД].objects.aggregate(result=Min('age')-Max('age')) --> Вывод разницы между минимальным и максимальным значением по полю age
SQL: SELECT (MIN age - MAX age) AS 'result' FROM [БД]

3.2 Вывод расчетного значения в отобранной выборке
[БД].objects.filter(pk__lt=3).aggregate(result=Min('age')-Max('age')) --> Вывод разницы между минимальным и максимальным значением по полю age для значений с id<3
SQL: SELECT (MIN age - MAX age) AS 'result' FROM [БД] WHERE id<3

4. Отбор не всех полей для SQL команды, а только выбранных
[БД].objects.values('title') --> Вывод только поля title для всех значений в базе данных
SQL: SELECT title FROM [БД]

5. Группировка записей
5.1.1 Группировка записей через функцию values() и annotate()
[БД].objects.values('title').annotate(Count('id')) --> Вывод количества записей с группировкой по полю title. Количество записано в переменную id__count.
SQL: SELECT title COUNT id AS id__count FROM [БД] GROUP BY title
ВАЖНО: Группировка в данной случае осуществляется по полю, отобранному через values(). 
Если выбрать все колонки all() или не указывать values(), выбраны будут все поля и группировка будет не иметь смысла. 

5.1.2 Группировка записей через функцию values() и annotate() с присваиванием ключа
[БД].objects.values('title').annotate(total=Count('id')) --> Вывод количества записей с группировкой по полю title. Все то же самое, только количество будет записано в переменную total.
SQL: SELECT title COUNT id AS total FROM [БД] GROUP BY title

5.2 Группировка записей с обратным связыванием

БД1 - База, в которой настроена колонка со связыванием (ForeignKey, OneToOneField, ManyToManyField)
БД2 - Вторая база
related_column - название колонки в БД1, связанной с БД2
[related_name] - название колонки в БД1, связанной с БД2 для обратного связывания

5.2.1 Вывод количества записей в БД1, сгруппированных по полю в БД2
[БД2].objects.annotate(total=Count('[related_name]')) --> Вывод количества записей в БД1, сгруппированных по pk в БД2. Количество записано в переменную total.
SELECT [БД2.ALL_COLUMNS] COUNT [БД1.id] AS total FROM [БД2] 
LEFT OUTER JOIN [БД1] ON [БД2.id]=[БД1.[название колонки, через которую БД1 и БД2 связаны]]
GROUP BY [БД2.ALL_COLUMNS]

5.2.2 Вывод количества записей в БД1, сгруппированных по полю в БД2, с критерием отбора
[БД2].objects.annotate(total=Count('[related_name]')).filter(total__gt=0) --> Вывод количества записей в БД1, сгруппированных по pk в БД2, количество которых больше нуля. Количество записано в переменную total.
SELECT [БД2.ALL_COLUMNS] COUNT [БД1.id] AS total FROM [БД2] 
LEFT OUTER JOIN [БД1] ON [БД2.id]=[БД1.[название колонки, через которую БД1 и БД2 связаны]]
GROUP BY [БД2.ALL_COLUMNS]
HAVING COUNT [БД1.id]>0

ВАЖНО: Данные запросы обрабатываются долго, поэтому для большого объема данных имеет смысл заменять их на вывод списка всех значений с дальнейшим его перебором через цикл.


----------------------------------------------------------------------------------------
Настройка Virtual environment venv

1. В cmd перейти в папку, в которую будет установлено виртуальное окружение. Создать venv в cmd:
    python -m venv VenvName
2. Для активации VenvName нужно перейти  в папку VenvName, в ней в папке Scripts запустить файл Activate.bat.
Для этого в cmd вводим команды:
    cd VenvName
    \Scripts\activate.bat
3. Для просмотра установленных расширений в venv можно набрать pip list (справочно)
4. В VS Code перейти в Command line -> Python: Select interpreter -> Выбрать созданный VenvName
5. Для Git:
    - Создаем txt файл с расширениями, установленными в данный VenvName. 
    Для этого в cmd активируем  вводим команду:
    pip freeze > requirement.txt
    - Комитим только этот файл. Остальные файлы добавляем в Git ignore










